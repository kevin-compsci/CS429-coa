#/* $begin ncopy-ys */
##################################################################
# ncopy.ys - Copy a src block of len words to dst.
# Return the number of positive words (>0) contained in src.
#
# Include your name and ID here.
# Kevin Nguyen
# kdn433
#
# Describe how and why you modified the baseline code.
# 1.) I unrolled the loop by a factor of 6 first because the code iterates
# through the same logic multiple times. As a result, when we spead out the
# function, we can compute more operations per iteration.
# 2.) Implemented iaddq because this instruction sets condition code
# and puts a value into a register quickly. Overall, saves computation time.
# 3.) Loaded all references from src near beginning to save computation time because
# afterwards the known values will be easily predicted further down the logic. This somewhat
# avoids dependency issues.
# 4.) I also did alternative stalls, but did not use explicit stalling. At any point where
# dependency had to occur, we can insert a useful instruction in-between the dependent instructions
# in order to stall and compute a needed operation. In this case, my code uses different
# registers for future parallel computations. As a result, saves time in the end.
#
# CPE: 8.26
#
##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = len
ncopy:
##################################################################
# You can modify this portion
	#Start
	andq %rdx, %rdx			# len can't be 0 or lower
	jle Done			# Exit immediately
	xorq %rax, %rax			# count = 0;
	iaddq $-6, %rdx
	jl LeftOvers
		
Loop:
	mrmovq (%rdi), %r9		# read val from src...
	mrmovq 8(%rdi), %r10
	mrmovq 16(%rdi), %r11
	mrmovq 24(%rdi), %r12
	mrmovq 32(%rdi), %r13
	mrmovq 40(%rdi), %r14
	rmmovq %r9, (%rsi)
	andq %r9, %r9			# val <= 0?
	jle E1				
	iaddq $1, %rax			# count++
E1:	
	rmmovq %r10, 8(%rsi)		# ...and store it to dst
	andq %r10, %r10			# val <= 0?
	jle E2				
	iaddq $1, %rax			# count++
E2:
	rmmovq %r11, 16(%rsi)
	andq %r11, %r11
	jle E3
	iaddq $1, %rax
E3:
	rmmovq %r12, 24(%rsi)
	andq %r12, %r12
	jle E4
	iaddq $1, %rax
E4:
	rmmovq %r13, 32(%rsi)
	andq %r13, %r13
	jle E5
	iaddq $1, %rax
E5:
	rmmovq %r14, 40(%rsi)
	andq %r14, %r14
	jle NextIteration
	iaddq $1, %rax
NextIteration:	
	iaddq $48, %rdi		# src++
	iaddq $48, %rsi		# dst++
	iaddq $-6, %rdx		# len--
	jge Loop		# if so, goto Loop:

LeftOvers:
	iaddq $5, %rdx
	jl Done
	mrmovq (%rdi), %r10
	mrmovq 8(%rdi), %r11	
	rmmovq %r10, (%rsi)
	andq %r10, %r10			
	jle Extra				
	iaddq $1, %rax		
Extra:
	iaddq $-1, %rdx
	jl Done
	rmmovq %r11, 8(%rsi)	
	mrmovq 16(%rdi), %r12	
	andq %r11, %r11		
	jle Extra2			
	iaddq $1, %rax	
Extra2:
	iaddq $-1, %rdx
	jl Done
	rmmovq %r12, 16(%rsi)	
	mrmovq 24(%rdi), %r13	
	andq %r12, %r12		
	jle Extra3		
	iaddq $1, %rax
Extra3:
	iaddq $-1, %rdx
	jl Done
	rmmovq %r13, 24(%rsi)	
	mrmovq 32(%rdi), %r14	
	andq %r13, %r13		
	jle Extra4			
	iaddq $1, %rax	
Extra4:
	iaddq $-1, %rdx
	jl Done
	rmmovq %r14, 32(%rsi)		
	andq %r14, %r14		
	jle Done				
	iaddq $1, %rax			

##################################################################
# Do not modify the following section of code
# Function epilogue.
Done:
	ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end ncopy-ys */
